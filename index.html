<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Power BI Docs</title>
    <style>
      /* -------------------------------------------
       BASIC RESET & LAYOUT
      ------------------------------------------- */
      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }
      body {
        font-family: Arial, sans-serif;
        color: #333;
        height: 100vh;
        overflow: hidden;
        display: flex;
        flex-direction: column;
      }
      /* -------------------------------------------
       WELCOME SCREEN
      ------------------------------------------- */
      #welcome-screen {
        flex: 1;
        display: flex;
        align-items: center;
        justify-content: center;
        background-color: #fafafa;
      }
      .welcome-container {
        text-align: center;
      }
      .welcome-container h1 {
        font-size: 24px;
        color: #0072c6;
        margin-bottom: 16px;
      }
      .welcome-buttons {
        margin-top: 24px;
      }
      .welcome-button {
        font-size: 16px;
        padding: 10px 20px;
        margin: 0 10px;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        background-color: #0072c6;
        color: #fff;
      }
      .welcome-button:hover {
        background-color: #005b9e;
      }
      /* -------------------------------------------
       MODAL OVERLAY
      ------------------------------------------- */
      .modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: rgba(0, 0, 0, 0.5);
        display: none;
        justify-content: center;
        align-items: center;
        z-index: 999;
      }
      .modal {
        background: #fff;
        padding: 20px;
        border-radius: 6px;
        width: 500px;
        max-width: 95%;
        position: relative;
      }
      .modal-header {
        font-size: 18px;
        margin-bottom: 10px;
        color: #0072c6;
      }
      .modal textarea {
        width: 100%;
        height: 150px;
        font-family: monospace;
        margin-bottom: 12px;
      }
      .modal-buttons {
        text-align: right;
      }
      .modal-buttons button {
        margin-left: 8px;
        padding: 8px 16px;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
      }
      .btn-cancel {
        background-color: #aaa;
        color: #fff;
      }
      .btn-submit,
      .btn-save {
        background-color: #0072c6;
        color: #fff;
      }
      /* -------------------------------------------
       EDIT DESCRIPTION COMBO EDITOR
      ------------------------------------------- */
      .edit-description-container {
        position: relative;
        width: 100%;
        min-height: 80px;
        margin-bottom: 12px;
      }
      .edit-description-highlight {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        padding: 4px;
        white-space: pre-wrap;
        word-wrap: break-word;
        font-family: monospace;
        font-size: 14px;
        color: black;
        pointer-events: none;
      }
      .edit-description-highlight a {
        color: #0c5db3;
        text-decoration: underline;
        pointer-events: none;
      }
      .edit-description-textarea {
        position: relative;
        width: 100%;
        background: transparent;
        color: transparent;
        caret-color: black;
        border: 1px solid #ccc;
        padding: 4px;
        resize: vertical;
        font-family: monospace;
        font-size: 14px;
        z-index: 1;
      }
      /* -------------------------------------------
       EDIT FORMULA COMBO EDITOR
      ------------------------------------------- */
      .edit-formula-container {
        position: relative;
        width: 100%;
        min-height: 80px;
        margin-bottom: 12px;
      }
      .edit-formula-highlight {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        padding: 4px;
        white-space: pre-wrap;
        word-wrap: break-word;
        font-family: Consolas, Monaco, "Andale Mono", "Ubuntu Mono", monospace;
        font-size: 14px;
        pointer-events: none;
      }
      .edit-formula-textarea {
        position: relative;
        width: 100%;
        background: transparent;
        color: transparent;
        caret-color: black;
        border: 1px solid #ccc;
        padding: 4px;
        resize: vertical;
        font-family: Consolas, Monaco, "Andale Mono", "Ubuntu Mono", monospace;
        font-size: 14px;
        z-index: 1;
      }
      /* -------------------------------------------
       APP CONTAINER
      ------------------------------------------- */
      #app-container {
        flex: 1;
        display: none;
      }
      .app-flex {
        display: flex;
        width: 100%;
        height: 100%;
      }
      /* -------------------------------------------
       SIDEBAR (MODIFIED FOR SCROLLING & PERCENT HEIGHT)
      ------------------------------------------- */
      .sidebar {
        width: 280px;
        background-color: #f8f9fa;
        border-right: 1px solid #ddd;
        display: flex;
        flex-direction: column;
        height: 100vh; /* Full viewport height */
      }
      .sidebar-top {
        background-color: #0072c6;
        padding: 16px;
        flex: 0 0 20%; /* 20% of sidebar height */
      }
      .sidebar-top h1 {
        color: #fff;
        font-size: 20px;
        margin-bottom: 8px;
      }
      .search-box {
        width: 100%;
        padding: 6px;
        font-size: 14px;
        border: none;
        border-radius: 4px;
        outline: none;
      }
      .nav-container {
        flex: 0 0 60%; /* 60% of sidebar height */
        overflow-y: scroll; /* Always show vertical scroll */
        font-size:13px;
      }
      .nav {
        list-style: none;
        padding: 0;
        margin: 0;
      }
      .nav-item {
        display: flex;
        align-items: center;
        cursor: pointer;
        padding: 8px 16px;
        user-select: none;
        transition: background-color 0.2s;
        border-bottom: 1px solid #eee;
      }
      .nav-item:hover {
        background-color: #f0f0f0;
      }
      .toggle-icon {
        margin-right: 8px;
        font-weight: bold;
        color: #666;
        width: 20px;
        text-align: center;
      }
      .item-label {
        flex: 1;
      }
      .children {
        display: none;
        margin-left: 20px;
        list-style: none;
        padding-left: 0;
      }
      .expanded > .toggle-icon::before {
        content: "−";
      }
      .collapsed > .toggle-icon::before {
        content: "+";
      }
      .nav-item.expanded + .children {
        display: block;
      }
      .selected {
        background-color: #e7f1ff;
        font-weight: bold;
      }
      /* -------------------------------------------
       PINNED CONTAINER IN SIDEBAR (MODIFIED: no absolute positioning, percent height)
      ------------------------------------------- */
      .sidebar-bottom {
        border-top: 1px solid #ddd;
        background-color: #f8f9fa;
        padding: 8px;
        display: flex;
        flex-direction: column;
        gap: 8px;
        flex: 0 0 20%; /* 20% of sidebar height */
      }
      .edit-data-button,
      .export-button {
        width: 100%;
        cursor: pointer;
        font-size: 14px;
        color: #fff;
        border: none;
        border-radius: 4px;
        padding: 8px 16px;
        outline: none;
        display: inline-flex;
        align-items: center;
        justify-content: center;
      }
      .edit-data-button:hover,
      .export-button:hover {
        opacity: 0.85;
      }
      .edit-data-button .icon,
      .export-button .icon {
        margin-right: 6px;
        font-size: 16px;
      }
      .edit-data-button {
        background-color: #0072c6;
      }
      .export-button {
        background-color: #d9534f;
      }
      /* -------------------------------------------
       MAIN CONTENT
      ------------------------------------------- */
      .main {
        flex: 1;
        overflow-y: auto;
        background-color: #fafafa;
        padding: 40px 20px;
        display: flex;
        justify-content: center;
        font-size:13px;
      }
      .main-content {
        width: 100%;
        max-width: 900px;
        background: #fff;
        padding: 30px 40px;
        margin-bottom: 40px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        overflow-y: auto;
        max-height: calc(100vh - 80px);
        font-size:13px;
      }
      .main-header {
        display: flex;
        justify-content: space-between;
        align-items: baseline;
        margin-bottom: 24px;
      }
      .main-header h2 {
        font-size: 26px;
        color: #0072c6;
        margin: 0;
      }
      .edit-button {
        cursor: pointer;
        font-size: 14px;
        color: #fff;
        background-color: #0072c6;
        border: none;
        border-radius: 4px;
        padding: 8px 16px;
        outline: none;
      }
      .edit-button:hover {
        background-color: #005b9e;
      }
      .description {
        margin-bottom: 16px;
        line-height: 1.5;
      }
      .code-block {
        margin-bottom: 24px;
        display: none;
      }
      .code-block pre {
        background-color: #f5f5f5;
        border-radius: 4px;
        padding: 1em;
        overflow: auto;
      }
      #main-toc {
        margin-top: 20px;
      }
      #main-toc h3 {
        margin-bottom: 12px;
        font-size: 18px;
        color: #0072c6;
      }
      .toc-table {
        width: 100%;
        border-collapse: collapse;
        margin-bottom: 24px;
        font-size:13px;
      }
      .toc-table thead th {
        background-color: #f0f0f0;
        font-weight: bold;
        padding: 8px;
        border-bottom: 2px solid #ccc;
        text-align: left;
      }
      .toc-table tbody tr {
        border-bottom: 1px solid #ddd;
      }
      .toc-table td {
        padding: 8px;
        vertical-align: top;
      }
      /* -------------------------------------------
       PRISM THEME for DAX (Updated Palette)
      ------------------------------------------- */
      .token.comment {
        color: #008000;
        font-style: italic;
      }
      .token.string {
        color: #a31515;
      }
      .token.keyword {
        color: #0000ff;
      }
      .token.function {
        color: #800080;
      }
      .token.operator {
        color: #000000;
      }
      .token.number,
      .token.boolean {
        color: #008080;
      }
      .token.punctuation {
        color: #000000;
      }
      /* -------------------------------------------
       SLASH MODAL (Feature 2)
      ------------------------------------------- */
      .slash-modal {
        position: absolute;
        background: #fff;
        border: 1px solid #ccc;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
        padding: 8px;
        z-index: 1000;
        width: 300px;
      }
      .slash-modal input {
        width: 100%;
        padding: 4px;
        margin-bottom: 4px;
        box-sizing: border-box;
      }
      .slash-modal ul {
        list-style: none;
        padding: 0;
        margin: 0;
        max-height: 150px;
        overflow-y: auto;
      }
      .slash-modal li {
        padding: 4px;
        cursor: pointer;
      }
      .slash-modal li:hover,
      .slash-modal li.selected {
        background-color: #e7f1ff;
      }
      /* -------------------------------------------
       CHANGELOG STYLES (Version Log)
      ------------------------------------------- */
      .changelog-section {
        margin-top: 20px;
        padding: 10px 15px;
        border-top: 1px solid #ddd;
      }
      .changelog-section h3 {
        font-size: 14px;
        color: #555;
        margin-bottom: 8px;
      }
      .changelog-entry {
        font-size: 12px;
        margin-bottom: 8px;
        padding: 6px;
        background-color: #f9f9f9;
        border: 1px solid #ddd;
        border-radius: 4px;
        position: relative;
      }
      .changelog-entry ul {
        list-style-position: inside;
        margin: 0;
        padding-left: 15px;
      }
      .changelog-addition {
        color: #228b22;
        font-size: 12px;
      }
      .changelog-removal {
        color: #d9534f;
        font-size: 12px;
      }
      .changelog-update {
        color: #6c71e7;
        font-size: 12px;
      }
      /* New CSS for changelog header grouping */
      .changelog-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 4px;
      }
      .version-container {
        display: flex;
        align-items: center;
        gap: 8px;
      }
      .author-container {
        display: flex;
        align-items: center;
        gap: 8px;
      }
      .version-info {
        font-weight: bold;
        font-size: 12px;
      }
      /* -------------------------------------------
       EDIT ICONS
      ------------------------------------------- */
      .edit-version-icon,
      .edit-action-icon,
      .edit-author-icon {
        cursor: pointer;
        font-size: 18px;
        color: #0072c6;
      }
      .edit-action-icon {
        font-size: 16px;
        margin-left: 8px;
      }
      .changelog-author {
        font-style: italic;
        font-size: 12px;
        color: #555;
      }
    </style>

    <!-- Global variables and scripts (unchanged, except for a few helper functions) -->
    <script>
      // By default the document is editable.
      var isDocumentEditable = true;

      // NEW GLOBALS for grouping edits during a session:
      // sessionBaseline holds the original document data (with changelog) as imported or last exported.
      // pendingVersion holds the version number of the new (un-exported) changes.
      let sessionBaseline = null;
      let pendingVersion = null;

      // NEW: Flag to indicate whether the document was imported (true) or created from scratch (false)
      let isImported = false;
      // NEW: When a document is imported, store the highest (baseline) version number.
      // (Now stored as a string in semantic format, e.g. "1.0.0")
      let importedMaxVersion = "1.0.0";

      /***********************************************************************
       * VERSION HELPER FUNCTIONS (Semantic Versioning)
       ***********************************************************************/
      function parseVersion(v) {
        const parts = v.split(".");
        return {
          major: parseInt(parts[0], 10) || 0,
          minor: parseInt(parts[1], 10) || 0,
          patch: parseInt(parts[2], 10) || 0,
        };
      }
      function versionToString(ver) {
        return ver.major + "." + ver.minor + "." + ver.patch;
      }
      function incrementVersion(versionStr) {
        const ver = parseVersion(versionStr);
        if (ver.patch < 9) {
          ver.patch++;
        } else {
          ver.patch = 0;
          if (ver.minor < 9) {
            ver.minor++;
          } else {
            ver.minor = 0;
            ver.major++;
          }
        }
        return versionToString(ver);
      }
      function compareVersions(v1, v2) {
        const ver1 = parseVersion(v1);
        const ver2 = parseVersion(v2);
        if (ver1.major !== ver2.major) return ver1.major - ver2.major;
        if (ver1.minor !== ver2.minor) return ver1.minor - ver2.minor;
        return ver1.patch - ver2.patch;
      }

      /***********************************************************************
       * NEW: Robust TSV parser to support quoted multi‐line fields.
       * This function splits the given TSV text into an array of rows,
       * each being an array of fields.
       ***********************************************************************/
      function parseTSV(tsv) {
        const rows = [];
        let currentRow = [];
        let currentField = "";
        let inQuotes = false;
        for (let i = 0; i < tsv.length; i++) {
          let c = tsv[i];
          if (inQuotes) {
            if (c === '"') {
              // If the next character is also a quote, add a literal quote.
              if (i + 1 < tsv.length && tsv[i + 1] === '"') {
                currentField += '"';
                i++;
              } else {
                inQuotes = false;
              }
            } else {
              currentField += c;
            }
          } else {
            if (c === '"') {
              inQuotes = true;
            } else if (c === "\t") {
              currentRow.push(currentField);
              currentField = "";
            } else if (c === "\n" || c === "\r") {
              // Handle possible \r\n pair
              if (c === "\r" && tsv[i + 1] === "\n") {
                i++;
              }
              currentRow.push(currentField);
              rows.push(currentRow);
              currentRow = [];
              currentField = "";
            } else {
              currentField += c;
            }
          }
        }
        // Add any remaining field/row.
        if (currentField !== "" || currentRow.length > 0) {
          currentRow.push(currentField);
          rows.push(currentRow);
        }
        return rows;
      }

      // ... (The remainder of the JavaScript remains unchanged except as noted below.)
    </script>
  </head>
  <body>
    <!-- WELCOME SCREEN -->
    <div id="welcome-screen">
      <div class="welcome-container">
        <h1>Welcome to Power BI Docs!</h1>
        <p>Select an option to start:</p>
        <div class="welcome-buttons">
          <button class="welcome-button" id="btn-create-data">
            Create from Data
          </button>
          <button class="welcome-button" id="btn-import-existing">
            Import from Existing Documentation
          </button>
        </div>
      </div>
    </div>

    <!-- CREATE-FROM-DATA MODAL -->
    <div class="modal-overlay" id="create-data-modal">
      <div class="modal">
        <div class="modal-header">Tab-Separated Data</div>
        <p style="font-size: 13px; margin-bottom: 8px">
          Find example format at : github.com/etohimself/pbidocs
        </p>
        <textarea id="tsv-input"></textarea>
        <div class="modal-buttons">
          <button class="btn-cancel" id="btn-cancel-create">Cancel</button>
          <button class="btn-submit" id="btn-submit-create">Submit</button>
        </div>
      </div>
    </div>

    <!-- APP CONTAINER -->
    <div id="app-container">
      <div class="app-flex">
        <!-- SIDEBAR -->
        <div class="sidebar">
          <div class="sidebar-top">
            <h1>Power BI Documentation</h1>
            <input
              type="text"
              id="searchBox"
              class="search-box"
              placeholder="Search..."
            />
          </div>
          <div class="nav-container">
            <ul id="nav" class="nav"></ul>
          </div>
          <div class="sidebar-bottom">
            <button class="edit-data-button" id="edit-data-button">
              <span class="icon">✎</span>Edit Data
            </button>
            <button class="export-button" id="export-button">
              <span class="icon">⎋</span>Export Docs
            </button>
          </div>
        </div>

        <!-- MAIN CONTENT AREA -->
        <div class="main">
          <div class="main-content">
            <div class="main-header">
              <h2 id="main-title">Welcome</h2>
              <button class="edit-button" id="edit-button">Edit</button>
            </div>
            <div class="description" id="main-description">
              Select an item from the sidebar to see details.
            </div>
            <div class="code-block" id="main-code-block">
              <pre><code id="main-code" class="language-dax"></code></pre>
            </div>
            <div id="main-toc">
              <h3>Contents</h3>
              <table class="toc-table">
                <thead>
                  <tr>
                    <th>Name</th>
                    <th>Description</th>
                  </tr>
                </thead>
                <tbody id="main-toc-body"></tbody>
              </table>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- EDIT ITEM MODAL -->
    <div class="modal-overlay" id="modal-overlay-edit">
      <div class="modal" id="edit-modal">
        <div class="modal-header">Edit Item</div>
        <div class="modal-field">
          <label for="edit-name">Name</label>
          <input type="text" id="edit-name" />
        </div>
        <div class="modal-field">
          <label for="edit-description">Description</label>
          <div
            id="edit-description-container"
            class="edit-description-container"
          >
            <div
              id="edit-description-highlight"
              class="edit-description-highlight"
            ></div>
            <textarea
              id="edit-description"
              class="edit-description-textarea"
            ></textarea>
          </div>
        </div>
        <div class="modal-field">
          <label for="edit-formula">Formula</label>
          <div id="edit-formula-container" class="edit-formula-container">
            <div
              id="edit-formula-highlight"
              class="edit-formula-highlight"
            ></div>
            <textarea
              id="edit-formula"
              class="edit-formula-textarea"
              rows="4"
            ></textarea>
          </div>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="btn-cancel-edit">Cancel</button>
          <button class="btn-save" id="btn-save-edit">Save</button>
        </div>
      </div>
    </div>

    <!-- EDIT VERSION MODAL (Version number only) -->
    <div class="modal-overlay" id="modal-overlay-version">
      <div class="modal" id="edit-version-modal">
        <div class="modal-header">Edit Version</div>
        <div class="modal-field" id="version-field">
          <label>Version: </label>
          <input
            type="number"
            id="version-major"
            value="1"
            style="width: 50px"
          />
          .
          <input
            type="number"
            id="version-minor"
            value="0"
            style="width: 50px"
          />
          .
          <input
            type="number"
            id="version-patch"
            value="0"
            style="width: 50px"
          />
        </div>
        <div class="modal-buttons" style="margin-top: 10px">
          <button class="btn-cancel" id="btn-cancel-version">Cancel</button>
          <button class="btn-save" id="btn-save-version">Save</button>
        </div>
      </div>
    </div>

    <!-- EDIT CHANGELOG ACTION MODAL -->
    <div class="modal-overlay" id="modal-overlay-action">
      <div class="modal" id="edit-action-modal">
        <div class="modal-header">Edit Changelog Action</div>
        <div class="modal-field">
          <label>Description:</label>
          <div style="display: flex; align-items: center">
            <span
              id="action-edit-prefix"
              style="font-weight: bold; margin-right: 4px"
            ></span>
            <textarea
              id="action-edit-text"
              style="width: 100%; height: 80px"
            ></textarea>
          </div>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="btn-cancel-action-edit">Cancel</button>
          <button class="btn-save" id="btn-save-action-edit">Save</button>
        </div>
      </div>
    </div>

    <!-- EDIT AUTHOR MODAL -->
    <div class="modal-overlay" id="modal-overlay-author">
      <div class="modal" id="edit-author-modal">
        <div class="modal-header">Edit Author</div>
        <div class="modal-field">
          <label for="author-input">Author Name:</label>
          <input type="text" id="author-input" value="Unknown" />
        </div>
        <div class="modal-buttons" style="margin-top: 10px">
          <button class="btn-cancel" id="btn-cancel-author">Cancel</button>
          <button class="btn-save" id="btn-save-author">Save</button>
        </div>
      </div>
    </div>

    <!-- Slash Lookup Modal (Feature 2) -->
    <div id="slash-modal" class="slash-modal" style="display: none">
      <input type="text" id="slash-search" placeholder="Search..." />
      <ul id="slash-results"></ul>
    </div>

    <!-- Hidden file input for importing existing HTML docs -->
    <input type="file" id="file-input" accept=".html" style="display: none" />

    <script>
      /***********************************************************************
       * 0. PRISM-LIKE CODE HIGHLIGHTING (DAX Grammar & Updated Palette)
       ***********************************************************************/
      var Prism = {
        manual: true,
        languages: {
          dax: {
            comment: /\-\-[^\n]*/g,
            string: /("[^"]*")|('[^']*')/g,
            keyword:
              /\b(?:CALCULATE|SUM|ALL|AVERAGEX|RELATED|FILTER|VALUES|DISTINCT|SUMX|COUNTROWS|MAX|MIN)\b/gi,
            function: /\b[A-Z_][A-Z0-9_]*(?=\s*\()/gi,
            boolean: /\b(?:TRUE|FALSE)\b/gi,
            number: /\b\d+(?:\.\d+)?\b/g,
            operator: /[\+\-\*\/=<>]|<>|&&|\|\|/g,
            punctuation: /[()\[\],]/g,
          },
        },
        highlightAll: function () {
          var codeBlocks = document.querySelectorAll(
            'code[class*="language-"]'
          );
          for (var i = 0; i < codeBlocks.length; i++) {
            Prism.highlightElement(codeBlocks[i]);
          }
        },
        highlightElement: function (el) {
          var langMatch = el.className.match(/language-(\w+)/);
          var lang = langMatch && langMatch[1] ? langMatch[1] : "dax";
          var grammar = Prism.languages[lang];
          if (!grammar) return;
          var text = el.textContent;
          var tokens = Prism.tokenizeSinglePass(text, grammar);
          el.innerHTML = Prism.stringify(tokens);
        },
        tokenizeSinglePass: function (text, grammar) {
          var matches = [];
          for (var tokenName in grammar) {
            var pattern = grammar[tokenName];
            var patterns = Array.isArray(pattern) ? pattern : [pattern];
            patterns.forEach(function (pat) {
              var flags = pat.flags || "";
              if (!flags.includes("g")) flags += "g";
              var re = new RegExp(pat.source, flags);
              var m;
              while ((m = re.exec(text)) !== null) {
                matches.push({
                  type: tokenName,
                  content: m[0],
                  start: m.index,
                  end: m.index + m[0].length,
                });
              }
            });
          }
          matches.sort((a, b) => a.start - b.start);
          var tokens = [];
          var lastPos = 0;
          for (var i = 0; i < matches.length; i++) {
            var mt = matches[i];
            if (mt.start < lastPos) continue;
            if (mt.start > lastPos) {
              tokens.push({
                type: "plain",
                content: text.slice(lastPos, mt.start),
              });
            }
            tokens.push({ type: mt.type, content: mt.content });
            lastPos = mt.end;
          }
          if (lastPos < text.length) {
            tokens.push({ type: "plain", content: text.slice(lastPos) });
          }
          return tokens;
        },
        stringify: function (tokens) {
          if (!Array.isArray(tokens)) return tokens.content;
          var html = "";
          tokens.forEach(function (t) {
            if (t.type === "plain") {
              html += t.content;
            } else {
              html +=
                '<span class="token ' + t.type + '">' + t.content + "</span>";
            }
          });
          return html;
        },
      };

      /***********************************************************************
       * 1. DATA & STATE
       ***********************************************************************/
      if (isDocumentEditable) {
        var docData = [];
      }
      let currentlySelectedLi = null;
      let currentItem = null;
      let itemMap = {};
      let currentSlashStart = null;

      // Globals for version & changelog action editing:
      let currentHomeItem = null;
      let currentChangelogIndex = null; // For version edits
      let currentActionEntryIndex = null; // For changelog action edits
      let currentActionKey = null;
      let currentActionTable = null;
      // NEW: Global for author edit modal
      let currentAuthorEntryIndex = null;

      /* DOM elements */
      const welcomeScreen = document.getElementById("welcome-screen");
      const createDataModal = document.getElementById("create-data-modal");
      const tsvInput = document.getElementById("tsv-input");
      const btnCreateData = document.getElementById("btn-create-data");
      const btnImportExisting = document.getElementById("btn-import-existing");
      const btnCancelCreate = document.getElementById("btn-cancel-create");
      const btnSubmitCreate = document.getElementById("btn-submit-create");
      const appContainer = document.getElementById("app-container");
      const navContainer = document.getElementById("nav");
      const searchBox = document.getElementById("searchBox");
      const mainTitleEl = document.getElementById("main-title");
      const mainDescEl = document.getElementById("main-description");
      const mainCodeBlock = document.getElementById("main-code-block");
      const mainCodeEl = document.getElementById("main-code");
      const mainTOC = document.getElementById("main-toc");
      const mainTOCBody = document.getElementById("main-toc-body");
      const editButton = document.getElementById("edit-button");
      const editDataButton = document.getElementById("edit-data-button");
      const exportButton = document.getElementById("export-button");
      const modalOverlayEdit = document.getElementById("modal-overlay-edit");
      const editModal = document.getElementById("edit-modal");
      const editNameInput = document.getElementById("edit-name");
      const editDescTextarea = document.getElementById("edit-description");
      const editDescHighlight = document.getElementById(
        "edit-description-highlight"
      );
      const editFormulaTextarea = document.getElementById("edit-formula");
      const editFormulaHighlight = document.getElementById(
        "edit-formula-highlight"
      );
      const btnCancelEdit = document.getElementById("btn-cancel-edit");
      const btnSaveEdit = document.getElementById("btn-save-edit");
      const fileInput = document.getElementById("file-input");
      const slashModal = document.getElementById("slash-modal");
      const slashSearch = document.getElementById("slash-search");
      const slashResults = document.getElementById("slash-results");

      // New DOM elements for version editing modal
      const modalOverlayVersion = document.getElementById(
        "modal-overlay-version"
      );
      const editVersionModal = document.getElementById("edit-version-modal");
      const versionMajorInput = document.getElementById("version-major");
      const versionMinorInput = document.getElementById("version-minor");
      const versionPatchInput = document.getElementById("version-patch");
      const btnCancelVersion = document.getElementById("btn-cancel-version");
      const btnSaveVersion = document.getElementById("btn-save-version");

      // New DOM elements for changelog action editing modal
      const modalOverlayAction = document.getElementById(
        "modal-overlay-action"
      );
      const editActionModal = document.getElementById("edit-action-modal");
      const actionEditPrefix = document.getElementById("action-edit-prefix");
      const actionEditText = document.getElementById("action-edit-text");
      const btnCancelActionEdit = document.getElementById(
        "btn-cancel-action-edit"
      );
      const btnSaveActionEdit = document.getElementById("btn-save-action-edit");

      // NEW: DOM elements for author editing modal
      const modalOverlayAuthor = document.getElementById(
        "modal-overlay-author"
      );
      const editAuthorModal = document.getElementById("edit-author-modal");
      const authorInput = document.getElementById("author-input");
      const btnCancelAuthor = document.getElementById("btn-cancel-author");
      const btnSaveAuthor = document.getElementById("btn-save-author");

      /***********************************************************************
       * 2. HELPER: HTML & REGEX ESCAPING
       ***********************************************************************/
      function escapeHtmlAttr(str) {
        return str
          .replace(/&/g, "&amp;")
          .replace(/"/g, "&quot;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;");
      }
      function escapeHtmlText(str) {
        return str
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;");
      }
      function escapeRegex(s) {
        return s.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      }

      /***********************************************************************
       * 3. NORMALIZE STRAY CHARACTERS
       ***********************************************************************/
      function normalizeDimensionArtifacts(txt) {
        return txt.replace(
          /([A-Za-z0-9_]+)">\1\[[A-Za-z0-9_]+\]/g,
          (fullMatch, grp1) => {
            const secondTblPos = fullMatch.indexOf(grp1, 1);
            const bracketPos = fullMatch.indexOf("[", secondTblPos);
            const bracketed = fullMatch.substring(bracketPos);
            return grp1 + bracketed;
          }
        );
      }

      /***********************************************************************
       * 4. WELCOME SCREEN & IMPORT
       ***********************************************************************/
      if (btnCreateData) {
        btnCreateData.addEventListener("click", () => {
          if (!isDocumentEditable) return;
          // When creating from data, mark as NOT imported.
          isImported = false;
          tsvInput.value = "";
          createDataModal.style.display = "flex";
        });
      }
      if (btnImportExisting) {
        btnImportExisting.addEventListener("click", () => {
          if (!isDocumentEditable) return;
          // When importing, mark as imported.
          isImported = true;
          fileInput.value = "";
          fileInput.click();
        });
      }
      if (fileInput) {
        fileInput.addEventListener("change", handleImportFile);
      }
      if (btnCancelCreate) {
        btnCancelCreate.addEventListener("click", () => {
          if (!isDocumentEditable) return;
          createDataModal.style.display = "none";
        });
      }
      if (btnSubmitCreate) {
        btnSubmitCreate.addEventListener("click", () => {
          if (!isDocumentEditable) return;
          const rawText = tsvInput.value.trim();
          if (!rawText) {
            alert("No data pasted!");
            return;
          }
          if (welcomeScreen.style.display !== "none") {
            docData = buildDocDataFromTSV(rawText, null);
            sessionBaseline = JSON.parse(JSON.stringify(docData));
            pendingVersion = null;
            // For documents created from scratch, set importedMaxVersion to home version (or default "1.0.0")
            const homeItem = docData.find((item) => item.type === "home");
            importedMaxVersion =
              homeItem && homeItem.version ? homeItem.version : "1.0.0";
            createDataModal.style.display = "none";
            welcomeScreen.style.display = "none";
            appContainer.style.display = "block";
            buildNavigation();
            buildItemMap(docData);
            selectNavItemFromLabel("Home");
          } else {
            docData = buildDocDataFromTSV(rawText, docData);
            createDataModal.style.display = "none";
            buildNavigation();
            buildItemMap(docData);
            selectNavItemFromLabel("Home");
          }
        });
      }

      function handleImportFile() {
        const file = fileInput.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = function (e) {
          const fileText = e.target.result;
          const docDataParsed = extractDocDataFromHtml(fileText);
          if (!docDataParsed) {
            alert("Could not parse docData from the selected file!");
            return;
          }
          docData = docDataParsed;
          sessionBaseline = JSON.parse(JSON.stringify(docDataParsed));
          pendingVersion = null;
          // Set importedMaxVersion from imported document (stored as semantic version string)
          const homeItem = docData.find((i) => i.type === "home");
          importedMaxVersion =
            homeItem && homeItem.version ? homeItem.version : "1.0.0";
          welcomeScreen.style.display = "none";
          appContainer.style.display = "block";
          buildNavigation();
          buildItemMap(docData);
          selectNavItemFromLabel("Home");
        };
        reader.readAsText(file);
      }
      function extractDocDataFromHtml(html) {
        const re = /(?:var\s+)?docData\s*=\s*(\[[\s\S]*?\])\s*;/;
        const match = re.exec(html);
        if (!match) return null;
        try {
          const dataStr = match[1];
          return JSON.parse(dataStr);
        } catch (e) {
          console.error("Failed to parse docData:", e);
          return null;
        }
      }

      /***********************************************************************
       * 5. BUILD DOC DATA
       ***********************************************************************/
      // Updated buildDocDataFromTSV now uses the custom parseTSV() function.
      // IMPORTANT: We now trim only the first three columns (Name, Parent, Type)
      // and leave the Expression column (which may be multi-line) untrimmed.
      function buildDocDataFromTSV(tsv, oldDocData) {
        // Use parseTSV() to correctly handle multi-line quoted fields.
        const rows = parseTSV(tsv);
        // If the header row (containing "parent") is present, remove it.
        if (
          rows.length > 0 &&
          rows[0].join("\t").toLowerCase().includes("parent")
        ) {
          rows.shift();
        }
        const baseData = sessionBaseline || oldDocData;
        const oldMap = baseData ? docDataToMap(baseData) : {};
        const homeItem = {
          label: "Home",
          type: "home",
          description: baseData
            ? getOldItemDescFormula(baseData, "home", "Home", null).description
            : "Welcome home page. Edit me!",
          formula: null,
          version: "1.0.0",
          changelog: [],
          children: [],
        };
        const measuresCat = {
          label: "Measures",
          type: "category",
          description: baseData
            ? getOldItemDescFormula(baseData, "category", "Measures", null)
                .description
            : "Automatically generated measures.",
          formula: null,
          children: [],
        };
        const tablesCat = {
          label: "Tables",
          type: "category",
          description: baseData
            ? getOldItemDescFormula(baseData, "category", "Tables", null)
                .description
            : "Automatically generated tables.",
          formula: null,
          children: [],
        };
        const newDocData = [homeItem, measuresCat, tablesCat];
        const newDims = {};
        const uniqueKeys = new Set();
        for (let i = 0; i < rows.length; i++) {
          // Instead of trimming every column (which removes newlines/indentation),
          // we trim only Name, Parent and Type. The Expression (column 4) is preserved.
          const row = rows[i];
          if (row.length < 3) continue;
          const rawName = row[0].trim();
          const rawParent = row[1].trim();
          const rawType = row[2].trim().toLowerCase();
          let rawExpression = row.length >= 4 ? row[3] : "";
          // Remove only the leading and trailing whitespace (but preserve internal newlines)
          rawExpression = rawExpression.replace(/^\s+|\s+$/g, "");
          let extractedDescription = "";
          let extractedFormula = "";
          if (rawExpression) {
            // If the expression is quoted, remove the surrounding quotes and unescape inner double quotes.
            if (
              (rawExpression.startsWith('"') && rawExpression.endsWith('"')) ||
              (rawExpression.startsWith("'") && rawExpression.endsWith("'"))
            ) {
              rawExpression = rawExpression.substring(
                1,
                rawExpression.length - 1
              );
              // Replace doubled double quotes with a single double quote.
              rawExpression = rawExpression.replace(/""/g, '"');
            }
            // Extract a description from a comment block /** description **/
            const descMatch = rawExpression.match(
              /\/\*\*\s*([\s\S]*?)\s*\*\*\//
            );
            if (descMatch) {
              extractedDescription = descMatch[1].trim();
              rawExpression = rawExpression
                .replace(/\/\*\*\s*([\s\S]*?)\s*\*\*\//, "")
                .trim();
            }
            extractedFormula = rawExpression;
          }

          const lineKey =
            rawType +
            "||" +
            rawName.toLowerCase() +
            "||" +
            rawParent.toLowerCase();
          if (uniqueKeys.has(lineKey)) continue;
          uniqueKeys.add(lineKey);

          if (rawType === "measure" && rawParent.toLowerCase() === "measures") {
            if (!measuresCat.children.find((m) => m.label === rawName)) {
              const oldMeasure = oldMap["measure:" + rawName + ":measures"];
              if (oldMeasure) {
                // Clone the old item and override if new expression is provided.
                let newMeasure = cloneItem(oldMeasure);
                if (extractedFormula) {
                  newMeasure.formula = extractedFormula;
                }
                if (extractedDescription) {
                  newMeasure.description = extractedDescription;
                }
                measuresCat.children.push(newMeasure);
              } else {
                measuresCat.children.push({
                  label: rawName,
                  type: "measure",
                  description: extractedDescription || "No description",
                  formula:
                    extractedFormula ||
                    "CALCULATE(\n  SUM(Fact_Table[" +
                      rawName.replace(/\s/g, "_") +
                      "]),\n  ALL()\n)",
                  children: [],
                });
              }
            }
          } else if (rawType === "table") {
            // When a table row is provided, update (if exists) or create a new table entry.
            let tableObj = tablesCat.children.find(
              (t) => t.label.toLowerCase() === rawName.toLowerCase()
            );
            if (tableObj) {
              if (extractedFormula) {
                tableObj.formula = extractedFormula;
              }
              if (extractedDescription) {
                tableObj.description = extractedDescription;
              }
            } else {
              const oldTable = oldMap["table:" + rawName + ":tables"];
              if (oldTable) {
                let newTable = cloneItem(oldTable);
                if (extractedFormula) {
                  newTable.formula = extractedFormula;
                }
                if (extractedDescription) {
                  newTable.description = extractedDescription;
                }
                tablesCat.children.push(newTable);
              } else {
                tablesCat.children.push({
                  label: rawName,
                  type: "table",
                  description: extractedDescription || "No description",
                  formula: extractedFormula || rawName + " (A standard table).",
                  children: [],
                });
              }
            }
          } else if (rawType === "dimension") {
            const parentTbl = rawParent;
            let tableObj = tablesCat.children.find(
              (t) => t.label === parentTbl
            );
            if (!tableObj) {
              const oldTable = oldMap["table:" + parentTbl + ":tables"];
              if (oldTable) {
                tableObj = cloneItem(oldTable);
              } else {
                tableObj = {
                  label: parentTbl,
                  type: "table",
                  description: "Auto-created table for " + parentTbl,
                  formula: parentTbl + " (A standard table).",
                  children: [],
                };
              }
              tablesCat.children.push(tableObj);
            }
            if (!newDims[parentTbl]) {
              newDims[parentTbl] = { dims: [], set: new Set() };
            }
            if (!newDims[parentTbl].set.has(rawName.toLowerCase())) {
              const oldDim = oldMap["dimension:" + rawName + ":" + parentTbl];
              if (oldDim) {
                let newDim = cloneItem(oldDim);
                if (extractedFormula) {
                  newDim.formula = extractedFormula;
                }
                if (extractedDescription) {
                  newDim.description = extractedDescription;
                }
                newDims[parentTbl].dims.push(newDim);
              } else {
                newDims[parentTbl].dims.push({
                  label: rawName,
                  type: "dimension",
                  description: extractedDescription || "",
                  formula:
                    extractedFormula ||
                    "RELATED(" +
                      parentTbl +
                      "[" +
                      rawName.replace(/\s/g, "_") +
                      "])",
                  children: [],
                });
              }
              newDims[parentTbl].set.add(rawName.toLowerCase());
            }
          }
        }
        tablesCat.children.forEach((tableObj) => {
          tableObj.children = newDims[tableObj.label]
            ? newDims[tableObj.label].dims
            : [];
        });
        // Only update the changelog if the document was imported.
        if (isImported && baseData) {
          updateChangelogDiff(newDocData, baseData);
        } else {
          // For new docs, do not change the version/changelog.
          homeItem.version = "1.0.0";
          homeItem.changelog = [];
          pendingVersion = null;
        }
        return newDocData;
      }
      function docDataToMap(docArr) {
        let map = {};
        function walk(items, parentLabel) {
          items.forEach((it) => {
            let key = "";
            if (it.type === "home") {
              key = "home:Home:null";
            } else if (it.type === "category") {
              key = "category:" + it.label + ":null";
            } else if (it.type === "measure") {
              key = "measure:" + it.label + ":measures";
            } else if (it.type === "table") {
              key = "table:" + it.label + ":tables";
            } else if (it.type === "dimension") {
              key = "dimension:" + it.label + ":" + (parentLabel || "Unknown");
            } else {
              key = it.type + ":" + it.label + ":" + (parentLabel || "none");
            }
            map[key] = it;
            if (it.type === "table") {
              walk(it.children || [], it.label);
            } else {
              walk(it.children || [], parentLabel);
            }
          });
        }
        walk(docArr, null);
        return map;
      }
      function cloneItem(item) {
        return {
          label: item.label,
          type: item.type,
          description: item.description,
          formula: item.formula,
          version: item.version,
          changelog: item.changelog
            ? JSON.parse(JSON.stringify(item.changelog))
            : undefined,
          children: item.children ? item.children.map(cloneItem) : [],
        };
      }
      function getOldItemDescFormula(oldDocData, type, label, parent) {
        const m = docDataToMap(oldDocData);
        let key = "";
        if (type === "home") {
          key = "home:Home:null";
        } else if (type === "category") {
          key = "category:" + label + ":null";
        } else if (type === "measure") {
          key = "measure:" + label + ":measures";
        } else if (type === "table") {
          key = "table:" + label + ":tables";
        } else if (type === "dimension") {
          key = "dimension:" + label + ":" + (parent || "Unknown");
        } else {
          return { description: "", formula: null };
        }
        if (m[key]) {
          return { description: m[key].description, formula: m[key].formula };
        }
        return { description: "", formula: null };
      }

      /***********************************************************************
       * 6. NEW HELPER: mergeChanges
       ***********************************************************************/
      function mergeChanges(existing, newChg) {
        const merged = {};
        const keys = new Set([
          ...(existing ? Object.keys(existing) : []),
          ...Object.keys(newChg),
        ]);
        keys.forEach((key) => {
          const val1 = existing ? existing[key] : undefined;
          const val2 = newChg[key];
          if (Array.isArray(val1) || Array.isArray(val2)) {
            const arr1 = Array.isArray(val1) ? val1 : [];
            const arr2 = Array.isArray(val2) ? val2 : [];
            merged[key] = Array.from(new Set([...arr1, ...arr2]));
          } else if (typeof val1 === "object" && typeof val2 === "object") {
            merged[key] = mergeChanges(val1, val2);
          } else {
            merged[key] = val2 !== undefined ? val2 : val1;
          }
        });
        return merged;
      }

      /***********************************************************************
       * 7. NEW HELPER: Update changelog diff
       ***********************************************************************/
      function updateChangelogDiff(newData, baseData) {
        const baseHome = docDataToMap(baseData)["home:Home:null"];
        let baseVersion =
          baseHome && baseHome.version ? baseHome.version : "1.0.0";
        const oldMapFinal = docDataToMap(baseData);
        const newMapFinal = docDataToMap(newData);
        let changes = {};

        let addedMeasures = [];
        let removedMeasures = [];
        for (let key in newMapFinal) {
          if (key.startsWith("measure:") && !oldMapFinal[key]) {
            addedMeasures.push(newMapFinal[key].label);
          }
        }
        for (let key in oldMapFinal) {
          if (key.startsWith("measure:") && !newMapFinal[key]) {
            removedMeasures.push(oldMapFinal[key].label);
          }
        }
        if (addedMeasures.length > 0) changes.addedMeasures = addedMeasures;
        if (removedMeasures.length > 0)
          changes.removedMeasures = removedMeasures;

        let addedTables = [];
        let removedTables = [];
        for (let key in newMapFinal) {
          if (key.startsWith("table:") && !oldMapFinal[key]) {
            addedTables.push(newMapFinal[key].label);
          }
        }
        for (let key in oldMapFinal) {
          if (key.startsWith("table:") && !newMapFinal[key]) {
            removedTables.push(oldMapFinal[key].label);
          }
        }
        if (addedTables.length > 0) changes.addedTables = addedTables;
        if (removedTables.length > 0) changes.removedTables = removedTables;

        let addedDimensions = {};
        let removedDimensions = {};
        for (let key in newMapFinal) {
          if (key.startsWith("dimension:") && !oldMapFinal[key]) {
            let parts = key.split(":");
            let table = parts[2];
            if (!addedDimensions[table]) addedDimensions[table] = [];
            addedDimensions[table].push(newMapFinal[key].label);
          }
        }
        for (let key in oldMapFinal) {
          if (key.startsWith("dimension:") && !newMapFinal[key]) {
            let parts = key.split(":");
            let table = parts[2];
            if (removedTables.includes(table)) continue;
            if (!removedDimensions[table]) removedDimensions[table] = [];
            removedDimensions[table].push(oldMapFinal[key].label);
          }
        }
        if (Object.keys(addedDimensions).length > 0)
          changes.addedDimensions = addedDimensions;
        if (Object.keys(removedDimensions).length > 0)
          changes.removedDimensions = removedDimensions;

        let updatedMeasures = [];
        for (let key in newMapFinal) {
          if (key.startsWith("measure:") && oldMapFinal[key]) {
            let oldItem = oldMapFinal[key];
            let newItem = newMapFinal[key];
            let updates = [];
            if (oldItem.description !== newItem.description)
              updates.push("description");
            if (oldItem.formula !== newItem.formula) updates.push("formula");
            if (updates.length > 0) {
              updatedMeasures.push(
                newItem.label + " (" + updates.join(", ") + ")"
              );
            }
          }
        }
        if (updatedMeasures.length > 0)
          changes.updatedMeasures = updatedMeasures;

        let updatedTables = [];
        for (let key in newMapFinal) {
          if (key.startsWith("table:") && oldMapFinal[key]) {
            let oldItem = oldMapFinal[key];
            let newItem = newMapFinal[key];
            let updates = [];
            if (oldItem.description !== newItem.description)
              updates.push("description");
            if (oldItem.formula !== newItem.formula) updates.push("formula");
            if (updates.length > 0) {
              updatedTables.push(
                newItem.label + " (" + updates.join(", ") + ")"
              );
            }
          }
        }
        if (updatedTables.length > 0) changes.updatedTables = updatedTables;

        let updatedDimensions = {};
        for (let key in newMapFinal) {
          if (key.startsWith("dimension:") && oldMapFinal[key]) {
            let oldItem = oldMapFinal[key];
            let newItem = newMapFinal[key];
            let updates = [];
            if (oldItem.description !== newItem.description)
              updates.push("description");
            if (oldItem.formula !== newItem.formula) updates.push("formula");
            if (updates.length > 0) {
              let parts = key.split(":");
              let table = parts[2];
              if (!updatedDimensions[table]) updatedDimensions[table] = [];
              updatedDimensions[table].push(
                newItem.label + " (" + updates.join(", ") + ")"
              );
            }
          }
        }
        if (Object.keys(updatedDimensions).length > 0)
          changes.updatedDimensions = updatedDimensions;

        let homeItem = newData.find((item) => item.type === "home");
        if (!homeItem) {
          homeItem = {
            label: "Home",
            type: "home",
            description: "",
            formula: null,
            children: [],
          };
          newData.unshift(homeItem);
        }
        if (Object.keys(changes).length > 0) {
          if (pendingVersion === null) {
            // Set the new pending version by incrementing the base version
            pendingVersion = incrementVersion(baseVersion);
          }
          let newChangelog =
            baseHome && baseHome.changelog
              ? JSON.parse(JSON.stringify(baseHome.changelog))
              : [];
          if (
            newChangelog.length > 0 &&
            newChangelog[newChangelog.length - 1].version === pendingVersion
          ) {
            newChangelog[newChangelog.length - 1].changes = mergeChanges(
              newChangelog[newChangelog.length - 1].changes,
              changes
            );
            newChangelog[newChangelog.length - 1].date =
              new Date().toISOString();
            if (!newChangelog[newChangelog.length - 1].author) {
              newChangelog[newChangelog.length - 1].author = "Unknown";
            }
          } else {
            newChangelog.push({
              version: pendingVersion,
              date: new Date().toISOString(),
              changes: changes,
              author: "Unknown",
            });
          }
          homeItem.version = pendingVersion;
          homeItem.changelog = newChangelog;
        } else {
          homeItem.version = baseVersion;
          homeItem.changelog = baseHome ? baseHome.changelog : [];
          pendingVersion = null;
        }
      }

      /***********************************************************************
       * 8. BUILD NAVIGATION, SELECT & UPDATE
       ***********************************************************************/
      function buildNavigation() {
        navContainer.innerHTML = "";
        buildNav(docData, navContainer);
      }
      function buildNav(items, parentEl) {
        items.forEach((item) => {
          const li = document.createElement("li");
          li.className = "nav-item collapsed";
          const toggleIcon = document.createElement("span");
          toggleIcon.className = "toggle-icon";
          if (!item.children || !item.children.length) {
            toggleIcon.style.visibility = "hidden";
          }
          const labelSpan = document.createElement("span");
          labelSpan.className = "item-label";
          labelSpan.textContent = item.label;
          li.addEventListener("click", (ev) => {
            if (ev.target === toggleIcon) {
              li.classList.toggle("expanded");
              li.classList.toggle("collapsed");
              ev.stopPropagation();
              return;
            }
            selectNavItem(li, item);
            ev.stopPropagation();
          });
          li.appendChild(toggleIcon);
          li.appendChild(labelSpan);
          parentEl.appendChild(li);
          if (item.children && item.children.length > 0) {
            const ul = document.createElement("ul");
            ul.className = "children";
            buildNav(item.children, ul);
            parentEl.appendChild(ul);
          }
        });
      }
      function selectNavItem(li, item) {
        if (currentlySelectedLi) {
          currentlySelectedLi.classList.remove("selected");
        }
        li.classList.add("selected");
        currentlySelectedLi = li;
        currentItem = item;
        updateContent(item);
      }
      function selectNavItemFromLabel(label) {
        const allLis = navContainer.querySelectorAll(".nav-item");
        for (let li of allLis) {
          const lbl = li.querySelector(".item-label");
          if (lbl && lbl.textContent === label) {
            li.click();
            break;
          }
        }
      }
      function buildItemMap(arr) {
        itemMap = {};
        function walk(items, parentLabel) {
          items.forEach((it) => {
            let key = "";
            if (it.type === "home") {
              key = "home:Home:null";
            } else if (it.type === "category") {
              key = "category:" + it.label + ":null";
            } else if (it.type === "measure") {
              key = "measure:" + it.label + ":measures";
            } else if (it.type === "table") {
              key = "table:" + it.label + ":tables";
            } else if (it.type === "dimension") {
              key = "dimension:" + it.label + ":" + (parentLabel || "Unknown");
            } else {
              key = it.type + ":" + it.label + ":" + (parentLabel || "none");
            }
            it.__key = key;
            itemMap[key] = it;
            if (it.type === "table") {
              walk(it.children || [], it.label);
            } else {
              walk(it.children || [], parentLabel);
            }
          });
        }
        walk(arr, null);
      }

      /***********************************************************************
       * 9. autoLinkReferences (for description & formulas)
       ***********************************************************************/
      function autoLinkReferences(text, currentKey) {
        let output = text;
        const dimRegex = /(\b[A-Za-z0-9_]+)\s*\[\s*([A-Za-z0-9_ ]+)\s*\]/g;
        output = replaceWithCallback(output, dimRegex, (full, tbl, dim) => {
          const dimensionKey = "dimension:" + dim + ":" + tbl;
          if (dimensionKey === currentKey) return full;
          const dimensionItem = itemMap[dimensionKey];
          if (dimensionItem) {
            const safeKey = escapeHtmlAttr(dimensionKey);
            const safeMatch = escapeHtmlText(full);
            return (
              '<a href="#" class="doc-link" data-ref="' +
              safeKey +
              '">' +
              safeMatch +
              "</a>"
            );
          }
          return full;
        });
        const measureRegex = /\[\s*([^\]]+?)\s*\]/g;
        output = replaceWithCallback(output, measureRegex, (full, mName) => {
          mName = mName.trim();
          const measureKey = "measure:" + mName + ":measures";
          if (measureKey === currentKey) return full;
          const measureItem = itemMap[measureKey];
          if (measureItem) {
            const safeKey = escapeHtmlAttr(measureKey);
            const safeMatch = escapeHtmlText(full);
            return (
              '<a href="#" class="doc-link" data-ref="' +
              safeKey +
              '">' +
              safeMatch +
              "</a>"
            );
          }
          return full;
        });
        let anchors = [];
        output = output.replace(/<a\b[^>]*>[\s\S]*?<\/a>/g, function (match) {
          anchors.push(match);
          return "{{ANCHOR_" + (anchors.length - 1) + "}}";
        });
        const tableRegex = /\b([A-Za-z0-9_]+)\b(?!\s*\[)/g;
        output = replaceWithCallback(output, tableRegex, (full, tName) => {
          const tableKey = "table:" + tName + ":tables";
          if (tableKey === currentKey) return full;
          const tableItem = itemMap[tableKey];
          if (tableItem) {
            const safeKey = escapeHtmlAttr(tableKey);
            const safeMatch = escapeHtmlText(full);
            return (
              '<a href="#" class="doc-link" data-ref="' +
              safeKey +
              '">' +
              safeMatch +
              "</a>"
            );
          }
          return full;
        });
        output = output.replace(
          /{{ANCHOR_(\d+)}}/g,
          (match, index) => anchors[index]
        );
        return output;
      }
      function replaceWithCallback(text, regex, callback) {
        let result = "";
        let lastIndex = 0;
        let match;
        while ((match = regex.exec(text)) !== null) {
          result += text.slice(lastIndex, match.index);
          const replacement = callback.apply(null, match);
          result += replacement;
          lastIndex = match.index + match[0].length;
        }
        result += text.slice(lastIndex);
        return result;
      }

      /***********************************************************************
       * 10. updateContent (view mode)
       ***********************************************************************/
      function updateContent(item) {
        mainTitleEl.textContent = item.label || "Untitled";
        let descNorm = normalizeDimensionArtifacts(item.description || "");
        let formNorm = item.formula
          ? normalizeDimensionArtifacts(item.formula)
          : "";
        mainDescEl.innerHTML = autoLinkReferences(descNorm, item.__key);
        wireDocLinks(mainDescEl);
        if (item.formula) {
          mainCodeBlock.style.display = "block";
          mainCodeEl.innerHTML = autoLinkReferences(formNorm, item.__key);
          wireDocLinks(mainCodeEl);
        } else {
          mainCodeBlock.style.display = "none";
          mainCodeEl.innerHTML = "";
        }
        Prism.highlightAll();
        mainTOC.style.display = "none";
        mainTOCBody.innerHTML = "";
        if (item.type === "category" || item.type === "table") {
          mainTOC.style.display = "block";
          item.children.forEach((ch) => {
            const tr = document.createElement("tr");
            const tdN = document.createElement("td");
            tdN.textContent = ch.label;
            const tdD = document.createElement("td");
            tdD.textContent = ch.description || "";
            tr.appendChild(tdN);
            tr.appendChild(tdD);
            mainTOCBody.appendChild(tr);
          });
        }
        if (item.type === "home") {
          let changelogDiv = document.getElementById("changelog-section");
          if (!changelogDiv) {
            changelogDiv = document.createElement("div");
            changelogDiv.id = "changelog-section";
            changelogDiv.className = "changelog-section";
            mainDescEl.parentNode.insertBefore(
              changelogDiv,
              mainDescEl.nextSibling
            );
          }
          let changelogHTML = "<h3>Changelog</h3>";
          if (item.changelog && item.changelog.length > 0) {
            // Loop from the last (current) entry to the oldest
            for (let i = item.changelog.length - 1; i >= 0; i--) {
              let entry = item.changelog[i];
              // Determine if this entry is editable.
              // For imported docs, only allow editing of entries created in this session.
              let editable = true;
              if (
                isImported &&
                compareVersions(entry.version, importedMaxVersion) <= 0
              ) {
                editable = false;
              }
              changelogHTML +=
                '<div class="changelog-entry" data-index="' + i + '">';
              changelogHTML += '<div class="changelog-header">';
              changelogHTML += '<div class="version-container">';
              changelogHTML +=
                '<span class="version-info">Version ' +
                entry.version +
                " - " +
                new Date(entry.date).toLocaleDateString() +
                "</span>";
              if (editable) {
                changelogHTML +=
                  '<span class="edit-version-icon" data-index="' +
                  i +
                  '">&#9998;</span>';
              }
              changelogHTML += "</div>";
              changelogHTML += '<div class="author-container">';
              changelogHTML +=
                '<span class="changelog-author">Modified by ' +
                (entry.author ? entry.author : "Unknown") +
                "</span>";
              if (editable) {
                changelogHTML +=
                  '<span class="edit-author-icon" data-index="' +
                  i +
                  '">&#9998;</span>';
              }
              changelogHTML += "</div>";
              changelogHTML += "</div>";
              changelogHTML += "<ul>";
              if (entry.changes.addedMeasures) {
                changelogHTML +=
                  '<li class="changelog-addition" data-change-key="addedMeasures">+ Added Measures: ' +
                  entry.changes.addedMeasures.join(", ");
                if (editable) {
                  changelogHTML +=
                    ' <span class="edit-action-icon" data-change-key="addedMeasures" data-index="' +
                    i +
                    '">&#9998;</span>';
                }
                changelogHTML += "</li>";
              }
              if (entry.changes.removedMeasures) {
                changelogHTML +=
                  '<li class="changelog-removal" data-change-key="removedMeasures">– Removed Measures: ' +
                  entry.changes.removedMeasures.join(", ");
                if (editable) {
                  changelogHTML +=
                    ' <span class="edit-action-icon" data-change-key="removedMeasures" data-index="' +
                    i +
                    '">&#9998;</span>';
                }
                changelogHTML += "</li>";
              }
              if (entry.changes.addedTables) {
                changelogHTML +=
                  '<li class="changelog-addition" data-change-key="addedTables">+ Added Tables: ' +
                  entry.changes.addedTables.join(", ");
                if (editable) {
                  changelogHTML +=
                    ' <span class="edit-action-icon" data-change-key="addedTables" data-index="' +
                    i +
                    '">&#9998;</span>';
                }
                changelogHTML += "</li>";
              }
              if (entry.changes.removedTables) {
                changelogHTML +=
                  '<li class="changelog-removal" data-change-key="removedTables">– Removed Tables: ' +
                  entry.changes.removedTables.join(", ");
                if (editable) {
                  changelogHTML +=
                    ' <span class="edit-action-icon" data-change-key="removedTables" data-index="' +
                    i +
                    '">&#9998;</span>';
                }
                changelogHTML += "</li>";
              }
              if (entry.changes.addedDimensions) {
                for (let tbl in entry.changes.addedDimensions) {
                  changelogHTML +=
                    '<li class="changelog-addition" data-change-key="addedDimensions" data-table="' +
                    tbl +
                    '">+ Added Dimensions to ' +
                    tbl +
                    ": " +
                    entry.changes.addedDimensions[tbl].join(", ");
                  if (editable) {
                    changelogHTML +=
                      ' <span class="edit-action-icon" data-change-key="addedDimensions" data-table="' +
                      tbl +
                      '" data-index="' +
                      i +
                      '">&#9998;</span>';
                  }
                  changelogHTML += "</li>";
                }
              }
              if (entry.changes.removedDimensions) {
                for (let tbl in entry.changes.removedDimensions) {
                  changelogHTML +=
                    '<li class="changelog-removal" data-change-key="removedDimensions" data-table="' +
                    tbl +
                    '">– Removed Dimensions from ' +
                    tbl +
                    ": " +
                    entry.changes.removedDimensions[tbl].join(", ");
                  if (editable) {
                    changelogHTML +=
                      ' <span class="edit-action-icon" data-change-key="removedDimensions" data-table="' +
                      tbl +
                      '" data-index="' +
                      i +
                      '">&#9998;</span>';
                  }
                  changelogHTML += "</li>";
                }
              }
              if (entry.changes.updatedMeasures) {
                changelogHTML +=
                  '<li class="changelog-update" data-change-key="updatedMeasures">~ Updated Measures: ' +
                  entry.changes.updatedMeasures.join(", ");
                if (editable) {
                  changelogHTML +=
                    ' <span class="edit-action-icon" data-change-key="updatedMeasures" data-index="' +
                    i +
                    '">&#9998;</span>';
                }
                changelogHTML += "</li>";
              }
              if (entry.changes.updatedTables) {
                changelogHTML +=
                  '<li class="changelog-update" data-change-key="updatedTables">~ Updated Tables: ' +
                  entry.changes.updatedTables.join(", ");
                if (editable) {
                  changelogHTML +=
                    ' <span class="edit-action-icon" data-change-key="updatedTables" data-index="' +
                    i +
                    '">&#9998;</span>';
                }
                changelogHTML += "</li>";
              }
              if (entry.changes.updatedDimensions) {
                for (let tbl in entry.changes.updatedDimensions) {
                  changelogHTML +=
                    '<li class="changelog-update" data-change-key="updatedDimensions" data-table="' +
                    tbl +
                    '">~ Updated Dimensions in ' +
                    tbl +
                    ": " +
                    entry.changes.updatedDimensions[tbl].join(", ");
                  if (editable) {
                    changelogHTML +=
                      ' <span class="edit-action-icon" data-change-key="updatedDimensions" data-table="' +
                      tbl +
                      '" data-index="' +
                      i +
                      '">&#9998;</span>';
                  }
                  changelogHTML += "</li>";
                }
              }
              changelogHTML += "</ul>";
              changelogHTML += "</div>";
            }
          } else {
            changelogHTML +=
              '<div class="changelog-entry"><em>No changes logged yet.</em></div>';
          }
          changelogDiv.innerHTML = changelogHTML;
          const editVersionIcons =
            changelogDiv.querySelectorAll(".edit-version-icon");
          editVersionIcons.forEach((icon) => {
            icon.addEventListener("click", (e) => {
              let index = icon.getAttribute("data-index");
              openVersionEditModal(item, index);
              e.stopPropagation();
            });
          });
          const editActionIcons =
            changelogDiv.querySelectorAll(".edit-action-icon");
          editActionIcons.forEach((icon) => {
            icon.addEventListener("click", (e) => {
              let index = icon.getAttribute("data-index");
              let changeKey = icon.getAttribute("data-change-key");
              let table = icon.getAttribute("data-table");
              openActionEditModal(index, changeKey, table);
              e.stopPropagation();
            });
          });
          const editAuthorIcons =
            changelogDiv.querySelectorAll(".edit-author-icon");
          editAuthorIcons.forEach((icon) => {
            icon.addEventListener("click", (e) => {
              let index = icon.getAttribute("data-index");
              openAuthorEditModal(item, index);
              e.stopPropagation();
            });
          });
        } else {
          let changelogDiv = document.getElementById("changelog-section");
          if (changelogDiv) {
            changelogDiv.innerHTML = "";
          }
        }
      }
      function wireDocLinks(container) {
        const links = container.querySelectorAll(".doc-link");
        links.forEach((a) => {
          a.addEventListener("click", (e) => {
            e.preventDefault();
            const key = a.getAttribute("data-ref");
            if (key) selectNavItemFromKey(key);
          });
        });
      }
      function selectNavItemFromKey(uKey) {
        const theItem = itemMap[uKey];
        if (!theItem) return;
        const allLis = navContainer.querySelectorAll(".nav-item");
        for (let li of allLis) {
          const lbl = li.querySelector(".item-label");
          if (lbl && lbl.textContent === theItem.label) {
            expandParents(li);
            li.click();
            break;
          }
        }
      }
      function expandParents(li) {
        let p = li.parentElement;
        while (p && p !== navContainer) {
          if (p.classList.contains("children")) {
            const prev = p.previousElementSibling;
            if (prev && prev.classList.contains("nav-item")) {
              prev.classList.remove("collapsed");
              prev.classList.add("expanded");
            }
          }
          p = p.parentElement;
        }
      }

      /***********************************************************************
       * 11. EDIT ITEM (Modal) with Enhanced Editors for Description & Formula
       ***********************************************************************/
      function updateDescriptionHighlight() {
        let raw = editDescTextarea.value;
        let highlighted = autoLinkReferences(
          normalizeDimensionArtifacts(raw),
          currentItem ? currentItem.__key : null
        );
        editDescHighlight.innerHTML = highlighted;
      }
      function updateFormulaHighlight() {
        let raw = editFormulaTextarea.value;
        let temp = document.createElement("code");
        temp.className = "language-dax";
        temp.textContent = raw;
        Prism.highlightElement(temp);
        editFormulaHighlight.innerHTML = temp.innerHTML;
      }
      function checkForSlashCommand() {
        let value = editDescTextarea.value;
        let pos = editDescTextarea.selectionStart;
        let before = value.slice(0, pos);
        let match = before.match(/\/(\S*)$/);
        if (match) {
          let query = match[1];
          currentSlashStart = pos - match[0].length;
          showSlashModal(query);
        } else {
          hideSlashModal();
        }
      }
      function showSlashModal(query) {
        let containerRect = document
          .getElementById("edit-description-container")
          .getBoundingClientRect();
        slashModal.style.top = containerRect.bottom + window.scrollY + "px";
        slashModal.style.left = containerRect.left + window.scrollX + "px";
        slashModal.style.display = "block";
        slashSearch.value = query;
        updateSlashResults(query);
        slashSearch.focus();
      }
      function hideSlashModal() {
        slashModal.style.display = "none";
      }
      function updateSlashResults(query) {
        slashResults.innerHTML = "";
        let results = [];
        Object.values(itemMap).forEach((item) => {
          if (
            item.type === "measure" ||
            item.type === "table" ||
            item.type === "dimension"
          ) {
            let disp = getDisplayTextForItem(item);
            if (disp.toLowerCase().indexOf(query.toLowerCase()) !== -1) {
              results.push({ item: item, display: disp });
            }
          }
        });
        results.sort((a, b) => a.display.localeCompare(b.display));
        results.forEach((result) => {
          let li = document.createElement("li");
          li.textContent = result.display;
          li.addEventListener("click", () => {
            insertSlashResult(result.item);
          });
          slashResults.appendChild(li);
        });
      }
      function getDisplayTextForItem(item) {
        if (item.type === "measure") return "[" + item.label + "]";
        if (item.type === "table") return item.label;
        if (item.type === "dimension") {
          let parts = item.__key.split(":");
          return parts[2] + "[" + parts[1] + "]";
        }
        return item.label;
      }
      function insertSlashResult(item) {
        let value = editDescTextarea.value;
        let pos = editDescTextarea.selectionStart;
        let before = value.slice(0, currentSlashStart);
        let after = value.slice(pos);
        let insertText = getDisplayTextForItem(item);
        let newValue = before + insertText + after;
        editDescTextarea.value = newValue;
        updateDescriptionHighlight();
        let newPos = before.length + insertText.length;
        editDescTextarea.selectionStart = editDescTextarea.selectionEnd =
          newPos;
        hideSlashModal();
        editDescTextarea.focus();
      }
      if (editDescTextarea) {
        editDescTextarea.addEventListener("input", () => {
          updateDescriptionHighlight();
          checkForSlashCommand();
        });
        editDescTextarea.addEventListener("keyup", (e) => {
          if (e.key === "Escape") {
            hideSlashModal();
          }
        });
      }
      if (editFormulaTextarea) {
        editFormulaTextarea.addEventListener("input", () => {
          updateFormulaHighlight();
        });
      }
      if (slashSearch) {
        slashSearch.addEventListener("input", (e) => {
          updateSlashResults(e.target.value);
        });
        slashSearch.addEventListener("keydown", (e) => {
          if (e.key === "Escape") {
            hideSlashModal();
            editDescTextarea.focus();
          }
        });
      }
      if (editButton) {
        editButton.addEventListener("click", () => {
          if (!isDocumentEditable) return;
          if (!currentItem) return;
          editNameInput.value = currentItem.label || "";
          editDescTextarea.value = currentItem.description || "";
          updateDescriptionHighlight();
          editFormulaTextarea.value = currentItem.formula || "";
          updateFormulaHighlight();
          modalOverlayEdit.style.display = "flex";
          editDescTextarea.focus();
        });
      }
      if (btnCancelEdit) {
        btnCancelEdit.addEventListener("click", () => {
          if (!isDocumentEditable) return;
          modalOverlayEdit.style.display = "none";
          hideSlashModal();
        });
      }
      if (btnSaveEdit) {
        btnSaveEdit.addEventListener("click", () => {
          if (!isDocumentEditable) return;
          if (!currentItem) {
            modalOverlayEdit.style.display = "none";
            return;
          }
          currentItem.label = editNameInput.value.trim();
          currentItem.description = editDescTextarea.value.trim();
          currentItem.formula = editFormulaTextarea.value.trim();
          if (currentlySelectedLi) {
            let lbl = currentlySelectedLi.querySelector(".item-label");
            if (lbl) lbl.textContent = currentItem.label;
          }
          updateContent(currentItem);
          buildItemMap(docData);
          // Only update changelog if the document was imported.
          if (sessionBaseline && isImported) {
            updateChangelogDiff(docData, sessionBaseline);
          }
          modalOverlayEdit.style.display = "none";
        });
      }

      /***********************************************************************
       * 12. NEW: Version/Changelog Edit Modal functions
       ***********************************************************************/
      function openVersionEditModal(homeItem, index) {
        currentHomeItem = homeItem;
        currentChangelogIndex = index;
        const entry = homeItem.changelog[index];
        let versionStr = entry.version.toString();
        const parts = versionStr.split(".");
        versionMajorInput.value = parts[0] || 1;
        versionMinorInput.value = parts[1] || 0;
        versionPatchInput.value = parts[2] || 0;
        modalOverlayVersion.style.display = "flex";
      }
      btnCancelVersion.addEventListener("click", () => {
        modalOverlayVersion.style.display = "none";
      });
      btnSaveVersion.addEventListener("click", () => {
        if (currentHomeItem && currentChangelogIndex !== null) {
          const major = parseInt(versionMajorInput.value.trim(), 10);
          const minor = parseInt(versionMinorInput.value.trim(), 10);
          const patch = parseInt(versionPatchInput.value.trim(), 10);
          if (isNaN(major) || isNaN(minor) || isNaN(patch)) {
            alert(
              "Please enter valid version numbers for major, minor, and patch."
            );
            return;
          }
          const newVersion = major + "." + minor + "." + patch;
          // Determine the baseline version. If editing the first entry after import,
          // the baseline is importedMaxVersion; otherwise, it is the previous entry’s version.
          let previousVersion = importedMaxVersion;
          if (currentHomeItem.changelog && currentChangelogIndex > 0) {
            previousVersion =
              currentHomeItem.changelog[currentChangelogIndex - 1].version;
          }
          if (compareVersions(newVersion, previousVersion) <= 0) {
            alert(
              "New version must be greater than previous version (" +
                previousVersion +
                ")."
            );
            return;
          }
          const entry = currentHomeItem.changelog[currentChangelogIndex];
          entry.version = newVersion;
          entry.date = new Date().toISOString();
          modalOverlayVersion.style.display = "none";
          updateContent(currentHomeItem);
        }
      });

      function openActionEditModal(entryIndex, changeKey, table) {
        currentActionEntryIndex = entryIndex;
        currentActionKey = changeKey;
        currentActionTable = table || null;
        let homeItem = currentItem;
        if (!homeItem || homeItem.type !== "home") {
          homeItem = docData.find((i) => i.type === "home");
        }
        // FIX: Set the currentHomeItem so that saving works correctly.
        currentHomeItem = homeItem;
        let entry = homeItem.changelog[entryIndex];
        let actionText = "";
        if (table) {
          let arr = entry.changes[changeKey][table];
          actionText = arr.join(", ");
        } else {
          let arr = entry.changes[changeKey];
          actionText = arr.join(", ");
        }
        actionText = actionText.trim();
        const allowedSymbols = ["+", "–", "~"];
        let symbol = "";
        if (allowedSymbols.includes(actionText.charAt(0))) {
          symbol = actionText.charAt(0);
          actionText = actionText.slice(1).trim();
        } else {
          if (changeKey.startsWith("added")) symbol = "+";
          else if (changeKey.startsWith("removed")) symbol = "–";
          else if (changeKey.startsWith("updated")) symbol = "~";
          else symbol = "";
        }
        actionEditPrefix.textContent = symbol;
        actionEditText.value = actionText;
        modalOverlayAction.style.display = "flex";
      }
      btnCancelActionEdit.addEventListener("click", () => {
        modalOverlayAction.style.display = "none";
      });
      btnSaveActionEdit.addEventListener("click", () => {
        const prefix = actionEditPrefix.textContent;
        const text = actionEditText.value;
        const newActionText = prefix + " " + text;
        if (
          currentHomeItem &&
          currentActionEntryIndex !== null &&
          currentActionKey
        ) {
          let entry = currentHomeItem.changelog[currentActionEntryIndex];
          if (currentActionTable) {
            entry.changes[currentActionKey][currentActionTable] = [
              newActionText,
            ];
          } else {
            entry.changes[currentActionKey] = [newActionText];
          }
          entry.date = new Date().toISOString();
          modalOverlayAction.style.display = "none";
          updateContent(currentHomeItem);
        }
      });

      // NEW: Open the Edit Author modal.
      function openAuthorEditModal(homeItem, index) {
        currentHomeItem = homeItem;
        currentAuthorEntryIndex = index;
        let entry = homeItem.changelog[index];
        authorInput.value = entry.author ? entry.author : "Unknown";
        modalOverlayAuthor.style.display = "flex";
      }
      btnCancelAuthor.addEventListener("click", () => {
        modalOverlayAuthor.style.display = "none";
      });
      btnSaveAuthor.addEventListener("click", () => {
        const newAuthor = authorInput.value.trim() || "Unknown";
        if (currentHomeItem && currentAuthorEntryIndex !== null) {
          let entry = currentHomeItem.changelog[currentAuthorEntryIndex];
          entry.author = newAuthor;
          entry.date = new Date().toISOString();
          modalOverlayAuthor.style.display = "none";
          updateContent(currentHomeItem);
        }
      });

      /***********************************************************************
       * 13. EDIT DATA => Re-export as TSV
       ***********************************************************************/
      if (editDataButton) {
        editDataButton.addEventListener("click", () => {
          if (!isDocumentEditable) return;
          const tsv = exportDocDataToTSV(docData);
          tsvInput.value = tsv;
          createDataModal.style.display = "flex";
        });
      }
      // Updated export to include 4 columns: Name, Parent, Type, Expression.
      // When exporting, if a description exists it is prepended as a comment block to the formula.
      function exportDocDataToTSV(arr) {
        let lines = [];
        function walk(items, parentLabel) {
          items.forEach((it) => {
            if (it.type === "home") {
            } else if (it.type === "category") {
              if (it.label === "Measures") walk(it.children, "Measures");
              else if (it.label === "Tables") walk(it.children, "Tables");
            } else if (it.type === "measure") {
              let expr = "";
              if (it.formula) {
                expr = it.formula;
              }
              if (it.description) {
                expr = "/**" + it.description + "**/" + expr;
              }
              if (!expr.trim()) {
                expr = "";
              }
              // Escape any double quotes by doubling them and then wrap in double quotes.
              expr = '"' + expr.replace(/"/g, '""') + '"';
              lines.push(it.label + "\tMeasures\tMeasure\t" + expr);
            } else if (it.type === "table") {
              let expr = "";
              if (it.formula) {
                expr = it.formula;
              }
              if (it.description) {
                expr = "/**" + it.description + "**/" + expr;
              }
              if (!expr.trim()) {
                expr = "";
              }
              expr = '"' + expr.replace(/"/g, '""') + '"';
              lines.push(it.label + "\tTables\tTable\t" + expr);
              walk(it.children, it.label);
            } else if (it.type === "dimension") {
              let expr = "";
              if (it.formula) {
                expr = it.formula;
              }
              if (it.description) {
                expr = "/**" + it.description + "**/" + expr;
              }
              if (!expr.trim()) {
                expr = "";
              }
              expr = '"' + expr.replace(/"/g, '""') + '"';
              lines.push(
                it.label + "\t" + (parentLabel || "") + "\tDimension\t" + expr
              );
            }
          });
        }
        walk(arr, null);
        return lines.join("\n");
      }

      /***********************************************************************
       * 14. EXPORT BUTTON => Export Read-Only HTML
       ***********************************************************************/
      if (exportButton) {
        exportButton.addEventListener("click", () => {
          if (!isDocumentEditable) return;
          let html = document.documentElement.outerHTML;
          html = html.replace(
            "var isDocumentEditable = true;",
            "var isDocumentEditable = false;"
          );
          const embedScript =
            "\nvar docData = " + JSON.stringify(docData) + ";";
          html = html.replace(
            "<\/script>",
            "\n" + embedScript + "\n<\/script>"
          );
          const blob = new Blob([html], { type: "text/html" });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = "PowerBI-Docs-ReadOnly.html";
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
          sessionBaseline = JSON.parse(JSON.stringify(docData));
          pendingVersion = null;
        });
      }

      /***********************************************************************
       * 15. SEARCH BOX
       ***********************************************************************/
      if (searchBox) {
        searchBox.addEventListener("input", () => {
          const q = searchBox.value.trim().toLowerCase();
          filterNav(docData, q);
        });
      }
      function filterNav(items, q) {
        function matches(it, q) {
          const labelMatch = it.label.toLowerCase().includes(q);
          let childMatch = false;
          if (it.children) {
            it.children.forEach((c) => {
              if (matches(c, q)) childMatch = true;
            });
          }
          it._filteredIn = labelMatch || childMatch || q === "";
          return it._filteredIn;
        }
        items.forEach((it) => matches(it, q));
        navContainer.innerHTML = "";
        buildFiltered(items, navContainer);
      }
      function buildFiltered(arr, parentEl) {
        arr.forEach((it) => {
          if (!it._filteredIn) return;
          const li = document.createElement("li");
          li.className = "nav-item collapsed";
          const tIcon = document.createElement("span");
          tIcon.className = "toggle-icon";
          if (!it.children || !it.children.length) {
            tIcon.style.visibility = "hidden";
          }
          const lab = document.createElement("span");
          lab.className = "item-label";
          lab.textContent = it.label;
          li.addEventListener("click", (e) => {
            if (e.target === tIcon) {
              li.classList.toggle("expanded");
              li.classList.toggle("collapsed");
              e.stopPropagation();
            } else {
              selectNavItem(li, it);
              e.stopPropagation();
            }
          });
          li.appendChild(tIcon);
          li.appendChild(lab);
          parentEl.appendChild(li);
          if (it.children && it.children.some((c) => c._filteredIn)) {
            li.classList.add("expanded");
            li.classList.remove("collapsed");
          }
          if (it.children && it.children.length > 0) {
            const ul = document.createElement("ul");
            ul.className = "children";
            buildFiltered(it.children, ul);
            if (ul.childNodes.length > 0) {
              parentEl.appendChild(ul);
            }
          }
        });
      }

      /***********************************************************************
       * 16. Disable Editing in Read-Only Mode on DOMContentLoaded
       ***********************************************************************/
      function disableEditing() {
        if (editDataButton) editDataButton.style.display = "none";
        if (exportButton) exportButton.style.display = "none";
        if (editButton) editButton.style.display = "none";
        if (document.getElementById("btn-create-data"))
          document.getElementById("btn-create-data").style.display = "none";
        if (document.getElementById("btn-import-existing"))
          document.getElementById("btn-import-existing").style.display = "none";
        if (createDataModal) createDataModal.style.display = "none";
        if (modalOverlayEdit) modalOverlayEdit.style.display = "none";
        if (document.getElementById("slash-modal"))
          document.getElementById("slash-modal").style.display = "none";
        if (welcomeScreen) welcomeScreen.style.display = "none";
        if (appContainer) appContainer.style.display = "block";
      }
      document.addEventListener("DOMContentLoaded", function () {
        if (!isDocumentEditable) {
          disableEditing();
          buildNavigation();
        }
      });
    </script>
  </body>
</html>
